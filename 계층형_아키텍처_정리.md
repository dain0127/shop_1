


# Controller :
## 1. Controller는 DTO를 통해 View 레이어와 직접 소통하는 계층이다.
## 2. Controller는 Service로부터 로직에 미반영된 데이터를 전송하고, Service로부터 로직이 반영된 데이터를 받는다. 

## 어느 URL로 접속하냐에 따라, 프로그램의 논리흐름을 조절한다.
### (비지니스 로직 직접 처리 X, DB에 접근 X)
비지니스 로직을 직접 처리한다는 것의 의미는 무엇인가? \
URL은 무엇인가?


# Service :
## 1. Service는 Controller로부터 데이터를 받아, 비지니스 로직으로 정제한 데이터를, DB에 저장한다.
## 물론 그 반대도.
## 2. Service는 다른 Service를 이용할 수 있다.
### 예를 들면 ItemService의 saveItem()은,
### ItemImgService의 saveItemImg()에게 ItemImg 엔티티의 저장 로직을 '위임'해야한다.
### saveItemImg()는, FileService에게 uploadFile()에게 바이너리 파일 저장을 '위임'해야한다.
### Dto의 특성상, 엔티티의 관계와 별개로, 클라이언트 사이드의 편의와 관련있는 까닭이다.

## 3. Service method의 업무 도메인은 정확히 divide 되어야 한다.
### 올바른 기준 ① “업무 행위(Use Case)”
예를 들어 '회원가입' 하나의 행위를 위한 비지니스 로직을 만들어야한다는 의미이다.
'주문 내역 보기'의 경우에는, 사용자가 주문한 내역을 리스트를 확인해야한다.

단순히 entity의 CURD의 단위로 나뉘어지는 것이 기준인 까닭은 아니다.
가령, '주문'의 경우에는 고려해야하는 비지니스 로직이 아래와 같다.
(input : OrderDto(item_id, count) -- 해당 item을 count만큼 주문했다.)
1. 1) item_id를 통해 Item을 찾는다. (R)
   2) Order를 생성한다. Order에 적절한 값을 넣어 초기화한다. 
2. OrderItem을 생성한다. 적절한 값을 넣어 초기화한다.
3. 각자의 reference 관계에 알맞게 객체의 참조값을 넣어준다.
4. Item의 stock을 주문량에 맞게 뺀다. (만약 부족하면 비지니스 로직에 예외 흐름으로 넘어간다.) (U) 
5. 엔티티들을 각각의 repository에 저장한다. (C)

이처럼 여러 엔티티가 다양한 쿼리문을 호출하며 하나의 단일한 기능을 통합적으로 이룬다.

따라서, 서비스는 어떤 경우에는 단순하여 하나의 쿼리문에 대응될 수 있겠으나,
복잡한 엔티티간의 상호작용이 필요한 서비스가 존재할 수 있다.

반복컨데, 컨트롤러는 Dto의 값만 잘 주고받으면 그만이다.

### 올바른 기준 ② “트랜잭션 경계”
### ❌ CRUD 기준
### ❌ 화면/컨트롤러 기준
### ❌ 엔티티 1:1 기준


# Repository :
## DB와 연결되어있다. Repository의 메소드는 쿼리문 하나와 같다.